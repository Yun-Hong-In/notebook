# 촌수계산

[2644번: 촌수계산](https://www.acmicpc.net/problem/2644)

### 문제 푼 방식

DFS 문제

- dict와 set을 활용해 친척관계도를 저장
- 관계는 양방향이므로 저장할 때 양쪽 관계를 모두 입력한다
- 찾고자 하는 두 사람의 관계를 DFS를 통해 탐색하고, 결과가 없다면 -1 출력

# 문자열집합

[14425번: 문자열 집합](https://www.acmicpc.net/problem/14425)

### 문제 푼 방식

- set에서 `in` 연산은 O(1)
- 집합 S를 만들기 위해 set에 모두 저장
- 그 후 주어진 입력을이 S에 있는지 확인하여 있으면 `count +=1`

# 방배정

[13300번: 방 배정](https://www.acmicpc.net/problem/13300)

### 문제 푼 방식

- defualtdict를 활용하여 학생들 분포를 저장
- 성별, 학년 순으로 입력이 들어오는데, 성별+학년을 key로 dict 생성
- 저장된 딕셔너리에서 각 value를 방의 최대인원으로 나눠 몫만큼 필요한 방 수에 더함
- 나머지가 있다면 방을 한개 더 더함

# 퍼즐

BFS문제

[1525번: 퍼즐](https://www.acmicpc.net/problem/1525)

### 문제 푼 방식

- 문자열을 '123456789'로 만들때 까지 횟수 출력 (0을 9로 바꿈)
- 현재의 인덱스를 (x, y)로 나타내는 방법은 `(i // 3, i % 3)`
- bfs를 통해 상하좌우 이동을 하고 이동한 지점의 인덱스는 `nx * 3 + ny`
- 문자열에서 인덱스에 맞춰 위치 바꾼 후
- 현재 상태와 현재까지 이동한 횟수를 딕셔너리에 저장
- 최종 출력은 딕셔너리에서 '123456789'의 value

# 30

[10610번: 30](https://www.acmicpc.net/problem/10610)

### 문제 푼 방식

- 30의 배수가 되기 위한 조건
    1. 각 자리수의 합이 3의 배수
    2. 일의 자리 수는 0
- 위 조건에 맞는 숫자만 담긴 리스트를 찾은 후 내림차순 정렬하여 `join`

# 등굣길

[코딩테스트 연습 - 등굣길](https://programmers.co.kr/learn/courses/30/lessons/42898)

### 문제 푼 방식

- 예전 수학문제 중 길찾기 경우의 수와 같은 문제
- 물웅덩이 자리는 0으로 만들고
- 현재 위치에서 왼쪽, 위쪽의 합이 현재 위치까지 오는 최단거리 수

# 적록색약

[10026번: 적록색약](https://www.acmicpc.net/problem/10026)

BFS

### 문제 푼 방식

- 전형적인 Flood Fill 문제
- 적록색약의 경우 `image_RG`로 G를 R로 바꾼 2차원 리스트 하나 더 만든 후
- 두 번 bfs 실행하여 각각 갯수 구함